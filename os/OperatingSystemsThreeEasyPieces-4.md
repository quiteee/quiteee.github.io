# Virtualization \| CPU-Scheduling

> 2021.09.27 \| 《Operating Systems: Three Easy Pieces》- 4

## Workload Assumptions 工作量假设

假设操作系统中的进程（也被称为 **job**），满足以下特征:

1.所有进程运行相同的时间

2.所有进程同时到达

3.一旦开始，进程需要运行到结束

4.所有进程只使用CPU（不需要I/O等）

5.每个进行的运行时间已知。

## Scheduling Metrics

用于比较不同的调度策略。

1. 周转时间(Turnaround Time): 进程完成时间减去进程到达的时间。

```math
T_{turnaround} = T_{completion} - T_{arrival}
```

> 周转时间是性能(performance)的指标

2. Jain公平指数(Jain’s Fairness Index): 

```math
J(x_1,x_2,...,x_n) = \frac{(\sum^{n}_{i=0}x_i)^2}{n*\sum^{n}_{i=0}x_i^2}
```

> Jain公平指数主要用来确定用户或应用程序是否获得了系统资源的公平共享。它是公平性(fairness)指标。

**performance** 和 **fairness** 在调度中通常是不一致的。例如通过阻止一些进程运行（降低公平性）以提高性能。

3. 响应时间(Response Time): 从任务到达，到任务被调度的时间差。

```math
T_{response} = T_{firstrun} − T_{arrival}

```


## First In, First Out (FIFO)

先到达的进程先运行。

**优点**：实现简单。

**缺点**：在**工作量假设1** 不满足的情况下，先到达的长耗时进程会阻塞后面的短耗时进程，导致整体的周转时间上升。

## Shorted Job First (SJF)

先运行最短的进程。

在 **工作量假设2** 满足的情况下，**SJF** 是最优解

在 **工作量假设2** 不满足的情况下，如果是长耗时进程先到达，后面的进程依然需要等待。（在满足工作量假设3，进程不会被中断的情况下）

## Shortest Time-to-Completion First (STCF)

最短剩余时间优先。

该调度策略不满足工作量假设3，即进程是会被中断，切换的。

每次有新任务时，会计算当前的所有任务，选择剩余时间最短的任务进行调度。

> 在仅有 ***周转时间*** 和 ***Jain公平指数*** 两个评估指标时，STCF是最优解。
>
> 但是由于计算机的交互需求，需要考虑另一个指标: response time

## Round Robin (RR)

每个进程只运行固定的时间片(time slice)，时间结束后，切换到其他进程。

> 时间片的长度一般是定时中断器的倍数。
> 
> 时间片越小，响应时间越少。但是频繁切换进程会增高上下文切换的成本，因此需要选择合适的时间片。

> 响应时间和周转时间通常不能兼顾，是一个取舍的问题。
>
> SJF和STCF优化周转时间，牺牲响应时间；RR优化响应时间，牺牲了周转时间。


## Multi-Level Feedback Queue(MLFQ，多级反馈队列)

事实上，** 工作量假设5** 通常都是不成立的，即无法知道每个进程的运行时间，这种情况下，SJF和STCF算法都是无意义的。

MLFQ旨在最小化响应时间的同时，在不知道进程运行时长时，最小化周转时间。

MLFQ的核心思想是：通过过去预测未来。

具体实现：

1. MLFQ有一组队列，每个队列赋予不用的优先级。
2. 优先级高的队列中的进程先运行。
3. 同优先级的进程按照RR调度。

进程的优先级通过观察进程的历史表现决定。

> 一个进程经常被I/O中断，说明这可能是一个交互式进程。要保证高优先级。
> 如果一个进行长时间密集使用CPU，可以适当降低其优先级。

#### 优先级调整方法

1. 当一个进程刚刚进入时，被放置到最高优先级队列。
2. 当一个进行运行完一个时间片后，优先级下降，被放置到下一个队列。
3. 当一个进行在运行完一个时间片之前，放弃使用CPU（被中断了），它会保持原来的优先级。

***优点***

1. 对于I/O密集型短任务，保证了响应快。
2. 接近SJF调度算法，短任务优先，保证了周转时间快。

***缺点***

1. 进程饥饿：优先级低的任务可能永远无法被调度。
2. 容易被攻击：恶意进程在时间片结束之前，发出I/O操作（对不关心的某个文件），从而放弃CPU；如果操作正确（例如，在放弃CPU之前运行99%的时间片），几乎可以垄断CPU。
3. 一个进程可能改变自身的行为：最开始是CPU密集型，后面转成I/O密集型，但是这个时候优先级已经被降低了。

#### 优先级调整方法补充

1. 优先级重启：在经过一段时间后，把所有进程移动到最高优先级队列。

> 这个可以解决缺陷1和3。
> 重启的时间间隔 **S**，也被称为 **Voo-Doo Constants**

2. 一个进程只能使用一个时间片，即使被中断了，后续的使用是累加的。一旦使用完时间片，就会降低优先级。

> I/0密集进程的优先级会缓慢下降。

#### 其他

不同队列的时间片长短不同，一般高优先级的时间片短（因为一般是I/O密集型任务），低优先级的时间片长。
